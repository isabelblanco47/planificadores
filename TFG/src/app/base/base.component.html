<div class="tituloCard">
  <mat-icon class="iconCard material-icons-outlined">home</mat-icon>
  <span> Guía Básica de Planificadores</span>
</div>


<div class="todos">
  <mat-divider> </mat-divider>
  <mat-tab-group style="overflow:hidden !important;">
    <mat-tab label="Algoritmo de Planificación FIFO">
      <div class="texto1">
        <h3>
          <mat-icon> library_books</mat-icon> Qué es FIFO
        </h3>
        <mat-divider></mat-divider>
        <br>El algoritmo de planificación FIFO (First-In, First-Out) se basa en el principio de que los procesos que
        llegan primero son los primeros en ser atendidos. En otras palabras, el primer proceso que llega a la cola de
        procesos es
        el primero en ser procesado por la CPU, y así sucesivamente hasta que todos los procesos en la cola hayan sido
        atendidos.<br>
      </div>

      <div class="texto2">
        <h3>
          <mat-icon> border_color</mat-icon> Ejemplo de FIFO
        </h3>
        <mat-divider></mat-divider><br>

        Supongamos que tenemos tres procesos en espera de ser ejecutados en la CPU, y llegan en el siguiente orden: <br>
        <br>
        <div style="display: flex; justify-content: center;">
          <img src="./assets/fifoTable.png" style="width: 30%;">
        </div>

        <br>El resultado de la ejecución de los procesos siguiendo el algoritmo de FIFO será el siguiente: <br>

        <br>
        <div style="display: flex; justify-content: center;">
          <img src="./assets/fifo.png">
        </div>

      </div>
    </mat-tab>
    <mat-tab label="Algoritmo de Planificación Prioritaria: No Preventiva">
      <div class="texto1">
        <h3>
          <mat-icon> library_books</mat-icon> Qué es Planificación Prioritaria No Preventiva
        </h3>
        <mat-divider></mat-divider><br>
        El algoritmo de planificación prioritaria no preventiva es un algoritmo de planificación de procesos en sistemas
        operativos donde cada proceso se asigna una prioridad y el proceso con la prioridad más alta se ejecuta primero.
        Si dos o más procesos tienen la misma prioridad, se pueden utilizar otros criterios, como el orden de llegada o
        el
        tiempo de ejecución previo, para determinar el orden de ejecución.<br>
        <br>
        A diferencia de los algoritmos de planificación preventiva, en los que el sistema operativo puede interrumpir un
        proceso en cualquier momento, el algoritmo de planificación prioritaria no preventiva permite que los procesos
        se
        ejecuten hasta que se completen o se bloqueen voluntariamente. Esto significa que un proceso con una prioridad
        baja puede bloquear el sistema si se ejecuta por un período de tiempo prolongado y no se bloquea por sí solo.
        <br>
        <br>Este algoritmo es útil en sistemas en los que se necesitan procesos de alta prioridad, como en sistemas de
        tiempo
        real, en los que la respuesta rápida es crucial, o en sistemas de control de procesos, donde se deben tomar
        decisiones rápidas en función de la entrada de sensores.<br>

        <br>Sin embargo, el algoritmo de planificación prioritaria no preventiva tiene la desventaja de que los procesos
        de
        baja prioridad pueden experimentar una inanición (starvation) y nunca ser ejecutados si hay muchos procesos de
        alta prioridad que están en la cola de procesos. Por lo tanto, es importante tener cuidado al asignar
        prioridades
        a los procesos y garantizar que los procesos de baja prioridad también tengan la oportunidad de ejecutarse.
      </div>
      <div class="texto2">
        <h3>
          <mat-icon> border_color</mat-icon> Ejemplo de Planificación Prioritaria No Preventiva
        </h3>
        <mat-divider></mat-divider><br>
        Supongamos que tenemos tres procesos, A, B y C, en una cola de procesos. El proceso A tiene una prioridad alta,
        el
        proceso B tiene una prioridad media y el proceso C tiene una prioridad baja. El tiempo de ejecución estimado
        para
        cada proceso es el siguiente:<br>

        <ul>
          <li><strong>Proceso A</strong>, que requiere 10 unidades de tiempo de CPU.
          <li><strong>Proceso B</strong>, que requiere 8 unidades de tiempo de CPU.
          <li><strong>Proceso C</strong>, que requiere 6 unidades de tiempo de CPU.
        </ul>

        El algoritmo de planificación prioritaria no preventiva ejecutará primero el proceso con la prioridad más alta.
        Por lo tanto, el proceso A se ejecutará primero, ya que tiene la prioridad más alta. Una vez que el proceso A se
        completa, el proceso B se ejecutará porque tiene la siguiente prioridad más alta. Finalmente, una vez que se
        completa el proceso B, el proceso C se ejecutará.<br>

        <br>El diagrama de Gantt para este ejemplo podría verse así:
        <br>
        | A | B | C |<br>
        0 10 18 24
        <br>
        <br>
        En resumen, el algoritmo de planificación prioritaria no preventiva ejecuta los procesos en función de su
        prioridad y permite que los procesos se ejecuten hasta que se completen o se bloqueen voluntariamente. Sin
        embargo, los procesos de baja prioridad pueden experimentar inanición si hay muchos procesos de alta prioridad
        en
        la cola de procesos.
      </div>
    </mat-tab>
    <mat-tab label="Algoritmo de Planificación Prioritaria: Preventiva">
      <div class="texto1">
        <h3>
          <mat-icon> library_books</mat-icon> Qué es Planificación Prioritaria Preventiva
        </h3>
        <mat-divider></mat-divider><br>
        El algoritmo de planificación prioritaria preventiva es un algoritmo de planificación de procesos en sistemas
        operativos donde cada proceso se asigna una prioridad y el proceso con la prioridad más alta se ejecuta
        primero.
        Si dos o más procesos tienen la misma prioridad, se pueden utilizar otros criterios, como el orden de llegada
        o el
        tiempo de ejecución previo, para determinar el orden de ejecución.<br>

        <br>A diferencia del algoritmo de planificación prioritaria no preventiva, en el que un proceso puede
        ejecutarse hasta
        que se complete o se bloquee voluntariamente, en el algoritmo de planificación prioritaria preventiva, el
        sistema
        operativo puede interrumpir un proceso en cualquier momento si un proceso de mayor prioridad llega a la cola
        de
        procesos. Esto significa que incluso si un proceso con una prioridad baja está en ejecución, el sistema
        operativo
        puede detenerlo y permitir que un proceso de mayor prioridad se ejecute.<br>

        <br>Este algoritmo es útil en sistemas en los que se necesitan procesos de alta prioridad y se debe garantizar
        una
        respuesta rápida y predecible. Por ejemplo, en sistemas de control de tráfico aéreo, donde la seguridad es una
        prioridad, se pueden utilizar algoritmos de planificación prioritaria preventiva para garantizar que los
        procesos
        críticos se ejecuten con prioridad y en tiempo real.<br>

        <br>Sin embargo, el algoritmo de planificación prioritaria preventiva también tiene desventajas. En
        particular, los
        procesos de baja prioridad pueden experimentar inanición si los procesos de alta prioridad continúan llegando
        a la
        cola de procesos. Para mitigar este problema, se pueden utilizar técnicas como la asignación de prioridades
        dinámicas, en las que las prioridades de los procesos se ajustan en función de su tiempo de ejecución previo o
        su
        tiempo de espera en la cola de procesos.<br>

        <br>En general, el algoritmo de planificación prioritaria preventiva es adecuado para sistemas en los que se
        necesita
        una respuesta rápida y predecible, pero se debe tener cuidado al asignar prioridades para evitar la inanición
        de
        procesos de baja prioridad.<br>
      </div>
      <div class="texto2">
        <h3>
          <mat-icon> border_color</mat-icon> Ejemplo de Planificación Prioritaria Preventiva
        </h3>
        <mat-divider></mat-divider><br>
      </div>
    </mat-tab>

    <mat-tab label="Algoritmo de Planificación Round-Robin">
      <div class="texto1">
        <h3>
          <mat-icon> library_books</mat-icon> Qué es Round-Robin
        </h3>
        <mat-divider></mat-divider><br>

        El algoritmo de planificación Round-Robin es muy similar al FIFO. La diferencia principal es que Round-Robin
        aplica planificación preferente para permitir que el sistema operativo cambie entre los diferentes procesos. Se
        define una pequeña unidad de tiempo, que suele tener una duración de entre 10 y 100 milisegundos. La cola de
        espera se trata como una cola circular y el planificador la recorre, asignando la CPU a cada proceso durante un
        intervalo de tiempo de hasta 1. <br>
        <br>Para implementar la planificación Round-Robin, tratamos de nuevo la cola de espera como una cola FIFO de
        procesos. Los nuevos procesos se añaden a la cola de la cola de procesos listos. <br>
        <br>El planificador de la CPU elige el primer proceso de la cola de listos, establece un temporizador para que se
        interrumpa después de 1 unidad de tiempo, y despacha el proceso. Se podrán dar dos situaciones diferentes. El
        proceso puede tener una ráfaga de CPU de menos de 1 unidad de tiempo. En este caso, el propio proceso liberará
        la CPU voluntariamente. El planificador pasará al siguiente proceso de la cola de espera. Si la ráfaga de CPU
        del proceso actualmente en ejecución es superior a 1 unidad de tiempo, el temporizador se disparará y provocará
        una interrupción al sistema operativo. Se ejecutará un cambio de contexto, y el proceso se colocará en la cola de
        espera. El planificador de la CPU seleccionará entonces el siguiente proceso en la cola de espera.

      </div>
      <div class="texto2">
        <h3>
          <mat-icon> border_color</mat-icon> Ejemplo de Round-Robin
        </h3>
        <mat-divider></mat-divider><br>

        <br>Supongamos que tenemos cuatro procesos, A, B, C y D, en una cola de procesos, y el sistema operativo tiene
        un
        quantum de tiempo de CPU de 2 unidades de tiempo. El orden de llegada de los procesos a la cola es el
        siguiente:<br>

        <br>
        <div style="display: flex; justify-content: center;">
          <img src="./assets/fifoTable.png" style="width: 30%;">
        </div>

        <br>El resultado de la ejecución de los procesos siguiendo el algoritmo Round-Robin será el siguiente: <br>

        <br>
        <div style="display: flex; justify-content: center;">
          <img src="./assets/round_robin.png">
        </div>

      </div>
    </mat-tab>
  </mat-tab-group>
</div>